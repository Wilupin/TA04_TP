\documentclass[10pt]{article}


% Tous les packages prédéfinis
\usepackage{introLatex}
\usepackage{headfootLatex}
\usepackage{shortcutLatex}
\usepackage{envLatex}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algpseudocode}

\graphicspath{{logos/}{figures/}}


\makeatletter
\def\hlinewd#1{%
\noalign{\ifnum0=`}\fi\hrule \@height #1 %
\futurelet\reserved@a\@xhline}
\makeatother


\begin{document}


% Titre du document
\vspace*{-22pt}
\begin{center}
\textbf{\Large Méthode multipole rapide pour un nuage de points}\\
\vspace*{4pt}
Gaétan Facchinetti \\
{\small 5 décembre 2016\\
\vspace*{5pt}
\textit{Université Paris-Saclay}, \textit{Ecole Normale Supérieure de Cachan}}, \\
\textit{Ecole Nationale Supérieure des Techniques Avancées}\\
\end{center}


\begin{center}
\rule{10cm}{1pt}
\end{center}

%\vspace*{4pt}

\begin{multicols}{2}



\section*{Question 1}

Nous avons créer une fonction permettant de renvoyer, pour une densité de point par longueur d'ondre $n_\lambda$ et une fréquence $f$ donnée, un tableau de coordonnées de l'ensemble des points du nuages ainsi que le nombre de $N$ points. Dans notre code ce nombre de points se calcule en fonction des paramètres par la formule, 

\begin{equation}
N = 4s_a(s_b-1) + 2(s_b-2)^{2}
\label{eq:N}
\end{equation}

Avec $s_a = \mathbb{E}(f n_\lambda L/c)+1$ et $s_b = \mathbb{E}(f n_\lambda l/c)+1$, où $L=1$ (m) et $l=0.5$ (m) sont les dimensions de la boite et $c$ la célérité de l'onde dans le milieu considéré Nous avons alors pu représenter en \refig{Q1} les points de discrétisation.


\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q1_4.pdf}
  \vspace*{-11pt}
  \caption{Points de discrétisation suivant les trois coordonnées spatiales (rouge). $N=252$, $n_\lambda = 10$, $f = c/L$. Pour faciliter la lecture les plans $x=0$, $y=0$ et $z=0$ ont été représentés en cyan.}
  \label{fig:Q1}
  \end{center}
\end{figure}
\vspace*{-22pt}


\vspace*{22pt}



\section*{Question 2}

Notons, pour $i \in \bbrac{1,N}$, $\xv_i$ le vecteur position du point du nuage indicé $i$. Introduisons alors la matrice de la fonction de Green G que nous definissons par $\G$ avec pour tout $(i,j) \in \bbrac{1,N}^{2}$ :

\begin{equation}
 \G_{i,j} =
 \begin{cases}
   G(\xv_i,\xv_j) = \frac{e^{ik\lb \xv_i - \xv_j \rb}}{\lb \xv_i - \xv_j \rb} & \text{si } 
   i\neq j \\
   0 & \text{si } i=j
 \end{cases}
 \label{eq:green}
\end{equation}


Nous notons $\tau_{a}$ le temps d'assemblage de cette matrice. Soit maintenant un vecteur $\rhov$ quelconque de $\R^{N}$. Nous notons $\tau_c$ le temps de calcul du produit matrice vecteur $\Vv = \G\rhov$.\\

Nous pouvons remarquer qu'à partir de $N \sim 10 000$ l'assemblade de la matrice est trop gourmand en mémoire et cela rend l'execution sous Matlab impossible. Nous avons donc fait varier $f$ à $n_\lambda$ fixé pour avoir, d'après \refeq{N}, une valeur de $N$ maximale de 9002. Puis nous avons représenté en \refig{Q2a} et \refig{Q2b} l'évolution de $\tau_a$ et $\tau_c$ en fonction de $N$.



\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q2a_4.pdf}
  \vspace*{-11pt}
  \caption{Temps d'assemblage de $\G$, $\tau_a$ (losanges rouge) et temps de calcul du produit matrice vecteur $\tau_c$ (ronds bleu) en fonction de $N$. Les deux courbes ont une allure parabolique mais nous pouvons remarquer que, les echelles étant différentes, le temps d'assemblage est plus long}
  \label{fig:Q2a}
  \end{center}
\end{figure}
\vspace*{-30pt}

\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q2b_4.pdf}
  \vspace*{-11pt}
  \caption{Temps d'assemblage de $\G$, $\tau_a$ (losanges rouge) et temps de calcul du produit matrice vecteur $\tau_c$  (ronds bleu) en fonction de $N$. Asymptotiquement $\log(\tau_{a/c}) \simeq 2\log(N)+K_{a/c}$ représentées en pointillé vert avec $K_{a/c}$ constante.}
  \label{fig:Q2b} 
  \end{center}
\end{figure}
\vspace*{-20pt}

Comme montré en \refig{Q2b}, l'évolution du logarithme de $\tau_a$ avec $N$ tend asymptotiquement vers une droite de pente 2. Il en est de même pour le logarithme de $\tau_c$ avec $N$. Nous avons pu vérifier cette évolution quadratique à l'aide d'une régression linéaire, ceci confirme l'évolution en $O(N^{2})$ du temps d'assemblage et de produit matrice vecteur.







\vspace*{22pt}

\section*{Question 3}

Nous avons calculé la quadrature de Gauss-Legendre à $L_q$ points en diagonsalisant la matrice tridiagonale définie dans l'énoncé. La methode utiliséé pour obtenir les points de quadrature est la méthode de Golub-Welsh\footnote{\textit{Calculation of Gauss Quadrature Rules}, G.H. Golub and J.H. Welsh \color{cyan}, Math. Comp. 23 (1969), 221-230 \color{black}, (Apr., 1969)}. Avec les notations du TP et $L_q$ le nombre de points de quadrature (à ne pas confondre avec $L$ la longueur du pavé) nous calculons, pour P polynôme tel que $\text{deg}P \le 2L_q-1$,

\begin{equation}
	\int_{-1}^{1}{P(t)dt} = \sum_{i=1}^{L_q}{\omega_i P(\lambda_i)}
\end{equation}

Ceci est équivalent, par un changement de variable, à

\begin{equation}
	\int_{0}^{\pi}{P(\cos(t))\sin(t)dt} = \sum_{i=1}^{L_q}{\omega_i P(\cos(\theta_i))}
\end{equation}

Nous avons testé cette quadrature avec $L_q = 3$ en comparaison de celle à 3 points dévleoppée lors du premier TP. Nous écrivons $I_{GL}$ le résultat par la quadrature de Gauss Legendre, $I_{1}$ le résultat pour la quadrature à trois points du premier TP, $I_{M}$ le résultat de la qudrature effectuée par Matlab et $I_v$ la valeur vraie pour l'integration de la fonction polynomiale $P$.

\begin{table}[H]
\centering
\begin{tabular}{m{2cm} |m{1cm} m{1cm} m{1cm} m{1cm}} 
   \hline
    \centering $P$ & $I_{GL}$ & $I_{1}$ & $I_{M}$ & $I_v$ \\
    \toprule
    \toprule
    $x \mapsto x$      & 0.00 & 0.00 & 0.00 & 0 \\
    $x \mapsto x^{2}$  & 0.667 & 0.667 & 0.667 & 2/3 \\
    $x \mapsto x^{4}$  & 0.400 & 0.667 & 0.400 & 2/5 \\
    \hline
\end{tabular}
\caption{Résultat des quadratures numériques}
\end{table}

Comme attendu nous observons que pour la quadrature de Gauss-Legendre donne les même resultats pour des polynômes de degré inférieur ou égal à 3 que la quadrature du premier TP. En revanche, comme nous pouvions nous y attendre cette nouvelle quadrature nous permet d'avoir une solution correcte pour des polynomes de degré 4 et 5, puisque la formule est bien exacte jusqu'au degé $2L_q-1$, ce que nous n'avions pas avant. 


\vspace*{12pt}

\section*{Question 4}

Notons, pour $l\in\N$ et $m\in\bbrac{-l,l}$ :
\begin{equation}
	C_{l,m} = \sqrt{\frac{2l+1}{4\pi}\frac{(l-m)!}{(l+m)!}}
\end{equation}

Nous avons, par définition, 
\begin{equation}
Y_{lm}(\theta, \phi) = C_{l,m}P_l^{m}\(\cos(\theta)\)e^{im\phi}
\end{equation}

En notant $I_{Y_{lm}}$ l'intégrale de $Y_{lm}$ sur la sphère unité (nous noterons $I_{GL,Y_{lm}}$ le résultat numérique de la quadrature), 
\begin{equation}
I_{Y_{lm}} = C_{l,m}\int_{0}^{\pi}{P_l^{m}\(\cos(\theta)\)\sin(\theta)d\theta}\int_{0}^{2\pi}e^{im\phi}d\phi
\end{equation}

Ainsi si $m \neq 0$ l'integrale sur $\phi$ donne directement $I = 0$.  De plus, d'après d'autres propriétés des polynomes de Legendre, la quadrature totale doit alors satisfaire les égalités suivantes :
\begin{equation}
\sum_{i,j}{\omega_i \omega_j Y_{lm}(\theta_j, \phi_i)} = 
	\begin{cases}
		0 & \text{ si } m \neq 0 \text{ ou } l \neq 0 \\
		\sqrt{4\pi} & \text{ si } m = 0 \text{ et } l = 0
	\end{cases}
\end{equation}

En particulier, la quadrature sur $\phi$ doit vérifier : 
\begin{equation}
	\sum_{i}{\omega_i e^{im\phi_i}} = 
	\begin{cases}
		0 & \text{ si } m \neq 0 \\
		2\pi & \text{ si } m = 0 \\
	\end{cases}
\end{equation}

Nous avons réalisé une quadraturre à $L_q+1$ points en $\theta$ et $2L_q+1$ points en $\phi$. Nous notons une intégration exacte, à erreur d'arrondi machine de l'ordre de $10^{-16}$, pour toute les harmoniques sphériques avec $l\le 2L_q$. Cependant pour $l = 2L_q+1$ nous pouvons commencer à remarquer des écarts (dus à la quadrature sur $\phi$) puisque le code nous donne une valeur numérique $I_{GL-Y_{lm}} = 2.576$ alors que $I_{Y_{lm}} = 0$ pour $Y_{l=9,m=9}$ en utilisant $L_q = 4$. Pour $l$ encore supérieur la quadrature sur $\theta$ donne aussi des valeurs éronnées et les résultats ne sont plus satisfaisants.\\
\indent
Nous aurions pu utiliser toute autre quadrature de Gauss, de Simpsons, etc. L'avantage de cette quadrature ci et d'intégrer exactement les harmoniques sphériques et de donner donc de très bon résultats pour nos expressions qui peuvent se décomposer avec une très bonne approximation sur une base constituée d'un nombre limité d'entre elles. Le deuxième avantage qui apparait est qu'il faut un nombre de points $(L_q+1)(2L_q+1)$ pour pouvoir intégrer exactement des harmoniques sphériques jusqu'à l'ordre $l=2L_q$ et ainsi utiliser un nombre de points restreint. \\


%\vspace*{22pt}










\section*{Question 5}

\subsection*{1. Mise en pratique}

Nous souhaitons calculer la décomposition en onde plane de la fonction de green G. Posons $\xv - \yv = (\yv_0 - \yv) + (\xv_0 - \yv_0) - (\xv_0 - \xv) = \rv + \rv_0$. Nous utilisons

\begin{equation}
	G(\xv, \yv) = \frac{\exp(ik|\xv-\yv|)}{|\xv-\yv|} \simeq \int_{S^{2}}{e^{ik\svh\rv}\Gc_Ld\svh}
\end{equation}

\vspace*{-11pt}

\begin{equation}
\Gc_{L_G} = \frac{ik}{4\pi}\sum_{p=0}^{L_G}{(2p+1)i^{p}h_p^{(1)}(k|\rv_0|)P_p(\cos(\svh, \rv_0))}
\end{equation}

\vspace*{-11pt}

\begin{equation}
\cos(\svh, \rv_0) = \frac{1}{|\rv_0|}< \begin{pmatrix} \sin(\theta)\cos(\phi)  \\ \sin(\theta)\sin(\phi)  \\ \cos(\theta) \end{pmatrix} , \rv_0 >
\end{equation}


L'intégrale sur la sphére unité est alors calculée par la quadrature déterminée dans la question précédente. En effet, la largeur de bande de l'équation a intégrer étant de $2L_G$ comme nous intégrons quasiment exactement avec une quadrature de $L_q$ en $\theta$ et $2L_q+1$ et $\phi$ les harmoniques sphériques $Y_{lm}$ avec $l \le 2L_q$ nous prenons ici une quadrature de $L_G+1$ points en $\theta$ et $2L_G+1$ points en $\phi$. \\
\indent
De plus, il faut être prudent et utiliser ici les fonctions de hankel sphériques et non celles définies sous Matlab avec la denomination \textit{besselh}. Ces fonctions sont définies par, pour $(z,p) \in \R^{*}_{+}\times\N$,

\begin{equation}
	h^{(1)}_{p}(z) = e^{iz}\sum_{k=0}^{p}{\frac{(p+k)!}{2^{k}(p-k)!}\frac{1}{z^{k+1}}}
\end{equation}

Pour être plus rapide dans le code ces fonctions sont en réalité calculées à l'aide de la formule de récurrence suivante. Ceci est pratique puisque nous avons besoin de toutes les fonctions de hankel jusuqu'à l'ordre $L$.

\begin{equation}
	h_{p+1}^{(1)}(z) =  \frac{2p+1}{z}h_{p}^{(1)}(z) - h_{p-1}^{(1)}(z) 
\end{equation}

De même, par souci de rapidité, nous n'utilisons pas non plus la fonction \textit{legendreP} intégrée au logiciel pour récupérer la valeur des polynômes de Legendre. Nous procédons aussi avec une formule de récurrence, ceci nous ayant permis d'en récupéréer les valeurs approximativement 10 fois plus vite qu'avec la fonction de Matlab. Pour $(x,p) \in \R\times\N$, 

\begin{equation}
	P_{p+1}(x) =  \frac{2p+1}{p+1}xP_{p}(x) - \frac{p}{p+1}P_{p-1}(x) 
\end{equation}


Enfin nous noterons aussi que pour réaliser des calculs rapides en vectorialisant au maximum les opérations effectuées nous avons beacoup utilisé la fonction \textit{bsxfun(@times, ..., ...)} du logiciel.





\vspace*{10pt}


\subsection*{2. Un exemple de cas test}

Pour tester nos codes nous avons utilisé le cas test $\rv = 0$ et $\rv_0 = \xv - \yv$. En effet dans ce cas,

\begin{equation}
\begin{split}
G(\xv,\yv) = \frac{ik}{4\pi}\sum_{p=0}^{L}{} (2p+1)i^{p}h_p^{(1)}(k|\rv_0|)  \\
 \times\int_{S^{2}}P_p(\cos(\svh, \rv_0))d\svh 
\end{split}
\end{equation}

Cependant pour $p\in\bbrac{0,L}$ comme notre quadrature intègre exactement les polynomes de degrés inférieur ou égal à $2L+1$ et d'après l'ortogonalité des polynômes de Legendre, il vient, 

\begin{equation}
G(\xv,\yv) = ikh^{(1)}_{0}(k|\rv_0|)
\end{equation}

Nous avons un résultat analytique très pratique pour vérifier le code. Ceci nous permet en outre de confirmer le choix des fonctions de Hankel et le bon fonctionnement de la quadrature sur les polynômes de Legendre. 



\vspace*{10pt}

\subsection*{3. Resultats}

Pour nous assurer du bon fonctionnement de notre code nous avons calculé différentes valeurs de la fonction de green en différents points en faisant varier $k$ et $L_q$. Nous notons $G_{\simeq}(\xv, \yv)$ l'approximation de la fonction de Green calculée aux points $\xv$ et $\yv$.  Nous introduisons aussi 


\begin{align}
 \varepsilon & = \frac{|G(\xv, \yv) - G_{\simeq}(\xv, \yv)|}{|G(\xv, \yv)|} \\
 \text{i.e.} \quad \varepsilon & = \|\xv -\yv\|_{2}|G(\xv, \yv) - G_{\simeq}(\xv, \yv)|
\end{align}


\end{multicols}

\rule{8cm}{1pt}

\begin{table}[H]
\centering
\begin{tabular}{m{0.5cm} m{0.5cm} | m{2cm} m{2cm} m{2cm} m{2cm} | m{2cm} m{2cm} m{1cm}} 
   \hline
    $k$ & $L_G$ & $\xv/L$ & $\yv/L$ & $\xv_0/L$ & $\yv_0/L$ & $G(\xv, \yv)$ & $G_{\simeq}(\xv,\yv)$ & $\varepsilon$ (\%) \\
    \toprule
    \toprule
    $4\pi$ & 2 & (0 0 0) & (1.5 0.5 0.5) & (0 0 0) & (1.5 0.5 0.5) & $-0.25 + 0.55i$ & $-0.25 + 0.55i$ & $10^{-18}$\\
    $4\pi$ & 10 & (0 0 0) & (1 0.5 0.5) & (0 0 0) & (1.5 0.5 0.5) & $-0.25 + 0.55i$ & $-0.25 + 0.55i$ & $10^{-18}$\\ \hline
    $4\pi$ & 5 & (0.1 0.1 0.1) & (1.1 0.4 0.6) & (0 0 0) & (1.5 0.5 0.5) & 0 & 0 & 0\\
    $4\pi$ & 10 & (0.1 0.1 0.1) & (1.1 0.4 0.6) & (0 0 0) & (1.5 0.5 0.5) & 0 & 0 & 0\\ \hline
    $4\pi$ & 5 & (0.1 0.1 0.1) & (0.3 0.3 0.3) & (0 0 0) & (0.3 0.3 0.3) & 0 & 0 & 0\\
    $4\pi$ & 5 & (0.1 0.1 0.1) & (1.1 0.4 0.6) & (0 0 0) & (1.5 0.5 0.5) & 0 & 0 & 0\\
    $4\pi$ & 10 & (0.1 0.1 0.1) & (1.1 0.4 0.6) & (0 0 0) & (1.5 0.5 0.5) & 0 & 0 & 0\\ \hline
    $4\pi$ & 5 & (0.1 0.1 0.1) & (0.3 0.3 0.3) & (0 0 0) & (0.3 0.3 0.3) & 0 & 0 & 0\\
    \hline
\end{tabular}
\caption{Résultat de la décomposition en ondes planes}
\end{table}



\hfill\rule{8cm}{1pt}

\begin{multicols}{2}

Nous pouvons commencer par remarquer que dans le cas $\xv=\xv_0$ et $\yv=\yv_0$ nous obtenons un resultat exact même pour $L_G=2$ qui est la plus petite valeur accessible dans notre code.  

\vspace*{22pt}


\section*{Question 6}

\subsection*{1. Partitionnement}

Nous avons réalisé le partitionnement, correspondant à un niveau de ce qu'aurait été l'octree dans un algorithme multi-niveau dans un fonction nous renvoyant une structure nommée \textbf{partition}. Les attributs essentiels de cette structure Matlab sont trois tableaux : \\

\begin{itemize}
\item du numéro des noeuds dans chaque boite. 
\item du nombre de noeuds dans chaque boite.
\item des coordonnées du centre de chaque boite. 
\end{itemize}

\vspace*{10pt}
Même si l'on ne prend pas en compte cette étape dans le temps de calcul du produit matrice vecteur il est bon d'essayer de ne pas la rendre trop longue. Pour ce faire nous n'avons réalis,é pour la création des boites de la partition et l'extraction des noeuds qui y appartiennent, que des boucles sur au maximum le nombre de boite et jamais sur le nombre de noeuds total qui est bien plus important. De plus pour ne pas surcharger la mémoire et comme beacoup des tableaux de \textbf{partition} sont creux nous avons utilisé une définition en tant que \textit{sparse} de ces matrices/tableaux. \\



\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q6.pdf}
  \vspace*{-11pt}
  \caption{Représentation de deux paquets deux points appartenants à deux boites de taille $d$ différentes en sortie de notre algorithme de partition (représentés en bleu et en noir). Celle en bleu contient moins de points car elle ne contient que des éléments du haut de la boite alors que celui en noir regroupe des points sur trois faces. $f=2c/L$, $n_\lambda = 10$, $d=0.3\lambda$.}
  \label{fig:Q6}
  \end{center}
\end{figure}

\subsection*{2. Algorithme FMM}

Après avoir réalisé le partitionnement nous nous sommes attaqués à l'écriture totale du code de résolution FMM à un noveau en réutilisant toutes les fonctions déjà écrites. Nous pouvons résumé ici la structure de l'algorithme final de la sorte : 

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State Initialisation des données du problèmes
        \State Maillage du domaine
        \State Initialisation des points de quadrature
        \State Creation des partitions
        \State Calcul du produit pour les noeuds non voisins
        \State Calcul des contributions des voisins
	\end{algorithmic}
\end{algorithm}
    

\vspace*{22pt}

\subsection*{3. Résultats}


Nous avons regardé l'erreur et norme $\| \text{ . }\|_{2}$ et en norme $\| \text{ . }\|_{\infty}$, entre le résultat de l'algorithme FMM et le résultat par le produit matrice vecteur classique en fonction de $L_G$. Nous notons plus précisément aussi $\G_{\simeq}$ la matrice associé comme en \refeq{green} à la fonction de Green précédemment définie $G_{\simeq}$ et de plus : 

\begin{equation}
\eta_{2} = \frac{\| (\G - \G_{\simeq})\rhov \|_{2}}{\| \G\rhov \|_{2}} \quad \text{et} \quad 
\eta_{\infty} = \frac{\| (\G - \G_{\simeq})\rhov \|_{\infty}}{\| \G\rhov \|_{\infty}} 
\end{equation}

La figure \refig{Q6b} montre, pour $\rhov$ = \textbf{1} (vecteur ayant toutes ces composantes à 1), l'évolution de ces coefficients avec $L_G$. 



\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q6b_2.pdf}
  \vspace*{-11pt}
  \caption{Evolution des écarts $\eta_2$ (points bleus) et $\eta_{\infty}$ (croix rouges) en fonction de $L_G$ représentant le nombre de points de quadrature et échelle logarithmique. $f=4c/L$, $n_\lambda =10$ et $d=0.3\lambda$ ce qui donne $N = 4002$ et un nombre de $162$ partitions}
  \label{fig:Q6b}
  \end{center}
\end{figure}
\vspace*{-22pt}

Nous remarquons qu'il y a un point de minimum. Avec la formule du cours nous avons une estimation de la valeur de $L_G$ à choisir pour se placer à ce minimum : 

\begin{equation}
	L_G = \sqrt{3}kd + 7.5\log{\(\sqrt{3}kd+\pi\)}
\end{equation}

Nous trouvons qu'alors $L_G=17$ au point. Sur notre graphique nous remarquons un minimum en $L_G=20$ ce qui est convenablement proche. Avec des erreurs relatives qui sont alors très faibles. 


\vspace*{22pt}

\section*{Question 7}


Nous montrons en \refig{Q7} l'évolution du temps de calcul $\tau_{FMM}$ par la méthode FMM et $\tau_{class}$par la méthode classique du produit matrice vecteur en fonction de $N$. Pour augmenter le nombre de points nous fixons $n_\lambda = 10$ et nous faisons varier la fréquence entre $0.2c/L$ et $5c/L$. Nous fixons $d=0.5\lambda$ à chaque itération pour cette figure et $L=10$ afin d'avoir une précision correcte sans pour autant trop alourdir le calcul déjà long que sa conception nécessite. En effet à $N \sim 2000$ le code met déjà 1 minutes. 

\begin{figure}[H]
  \begin{center}
  \includegraphics[width=0.95\columnwidth]{Q7.pdf}
  \vspace*{-11pt}
  \caption{Evolution du temps de calcul du produit matrice vecteur par la méthode classique $\tau_{class}$ (rouge) et par la méthode FMM $\tau_{FMM}$ (bleu) avec $N$. Les courbes jaunes et vertes correspondents aux modélisations en loi de puissance réalisés avec Matlab.}
  \label{fig:Q7}
  \end{center}
\end{figure}
\vspace*{-22pt}

Nous remarquons que, même si cela ne parait pas évident à cause des echelles différentes mises en jeu sur la figure, la courbe de $\tau_{FMM}$ décroit moins vite que celle de $\tau_{class}$. Afin de vérifier cette tendance sont représentés en en jaune et vert les courbes de meilleures interpolations avec les équations suivantes : $\tau_{FMM} \simeq 1.63\times10^{-4} \times N^{1.55}$ (s) et $\tau_{class} \simeq 1.97\times10^{-9}  N^{1.95}$ (s). Même en utilisant l'option \textit{-singleCompThread} de Matlab la complexité du produit classique est légérement en dessous de la complexité théorique ceci peut s'expliquer par le fait qu'il nous aurait fallu peut être plus de pointsà N plus grand pour ne prendre en compte que le comportmeent asymptotique. Malgré cela nous ne somme pas loin de la complexité théorique et ceci nous permet de voir que notre méthode FMM se rapproche aussi de sa complexité théorique en $O(N^{3/2})$. \\
\indent
Cependant, nous observons une courbe sui évolue par \textit{paliers}. Sachant que sur chaque \textit{palier} le nombre de partition est constant nous pouvons en conclure qu'en augmentant la fréquence, nous rajoutons par étapes des partitions et aisni nous obtenons une augmentation par petits sauts du temps. 


\vspace*{22pt}
\section*{Question 8}

Nous pouvons remarquer que bien que malgrès une complexité plus avantageuse et nos effort pour le rendre le plus rapide possible ce nouveau algorithme met plus de temps à s'executer que le produit réalisé classiquement pour le nombre de points (qui reste relativement faible) que nous aons pu tester. En effet nous avons pour $N = 6012$, un temps $\tau_{FMM} = 108$ s et $\tau_{class} = 0.05$ s. Nous pouvons dire, en comparant les deux courbes de la question précédente  et de la question 2 qu'il faudrait atteindre $N \sim 10^{7}$ pour que l'utilisation de la FMM mono-niveau soit, dans ce cas, utile si l'on prend en compte le temps d'assemblage de la matrice dans la méthode classique. Ce nombre est trop malheureusement important et il serait necessaire de réussir à optimiser le temps d'éxecution du code de manière générale ou de passer par un algorithme multi-niveaux.

\end{multicols}



\end{document}
